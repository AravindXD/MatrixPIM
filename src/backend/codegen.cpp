#include "../../include/backend/codegen.h"
#include <fstream>
#include <iostream>
#include <iomanip>
#include <algorithm>
#include <cmath>
#include <cassert>

namespace Backend {

// Constructor
CodeGenerator::CodeGenerator(std::shared_ptr<MemoryMap::MemoryMapper> memoryMapper)
    : memoryMapper_(memoryMapper) {
}

// Generate instructions from parsed matrices and operations
std::vector<PIM_ISA::Instruction> CodeGenerator::generateInstructions(
    const std::vector<Frontend::MatrixInfo>& matrices,
    const std::vector<Frontend::MatrixOperation>& operations) {
    
    std::vector<PIM_ISA::Instruction> instructions;
    
    // Map matrices to memory
    for (const auto& matrix : matrices) {
        MemoryMap::MatrixDimensions dimensions(matrix.rows, matrix.cols);
        memoryMapper_->mapMatrix(matrix.name, dimensions);
        
        if (verbose_) {
            std::cout << "Mapped matrix " << matrix.name << " (" 
                     << matrix.rows << "x" << matrix.cols << ") to memory" << std::endl;
            
            auto range = memoryMapper_->getMatrixAddressRange(matrix.name);
            std::cout << "  Address range: " << range.startAddress << " - " << range.endAddress << std::endl;
        }
    }
    
    // Generate initialization instructions for LUT cores
    generateInitInstructions(instructions);
    
    // Generate instructions for each operation
    for (const auto& op : operations) {
        switch (op.type) {
            case Frontend::OperationType::MULTIPLY:
                generateMatrixMultiplyInstructions(op, instructions);
                break;
                
            // Add other operation types here
                
            default:
                std::cerr << "Warning: Unsupported operation type" << std::endl;
                break;
        }
    }
    
    // Add termination instruction
    instructions.push_back(PIM_ISA::createEndInstruction());
    
    return instructions;
}

// Write generated instructions to an output file
bool CodeGenerator::writeToFile(const std::vector<PIM_ISA::Instruction>& instructions, const std::string& outputFile) {
    std::ofstream file(outputFile);
    if (!file.is_open()) {
        std::cerr << "Error: Could not open output file " << outputFile << std::endl;
        return false;
    }
    
    // Write header
    file << "// pPIM Assembly generated by pPIM Compiler" << std::endl;
    file << "// Format: <Instruction> <Parameters>" << std::endl;
    file << std::endl;
    
    // Write instructions
    for (const auto& instruction : instructions) {
        file << instruction.toString() << std::endl;
    }
    
    return true;
}

// Set verbose mode
void CodeGenerator::setVerbose(bool verbose) {
    verbose_ = verbose;
}

// Generate instructions for matrix multiplication
void CodeGenerator::generateMatrixMultiplyInstructions(
    const Frontend::MatrixOperation& op,
    std::vector<PIM_ISA::Instruction>& instructions) {
    
    if (op.inputs.size() != 2) {
        throw std::runtime_error("Matrix multiplication requires exactly 2 input matrices");
    }
    
    const std::string& matrixA = op.inputs[0];
    const std::string& matrixB = op.inputs[1];
    const std::string& matrixC = op.output;
    
    // Get matrix dimensions
    uint32_t rowsA = memoryMapper_->getMatrixDimensions(matrixA).rows;
    uint32_t colsA = memoryMapper_->getMatrixDimensions(matrixA).cols;
    uint32_t rowsB = memoryMapper_->getMatrixDimensions(matrixB).rows;
    uint32_t colsB = memoryMapper_->getMatrixDimensions(matrixB).cols;
    
    // Verify dimensions
    if (colsA != rowsB) {
        throw std::runtime_error("Invalid matrix dimensions for multiplication: " + 
                                matrixA + "(" + std::to_string(rowsA) + "x" + std::to_string(colsA) + ") * " +
                                matrixB + "(" + std::to_string(rowsB) + "x" + std::to_string(colsB) + ")");
    }
    
    // Calculate result dimensions
    uint32_t rowsC = rowsA;
    uint32_t colsC = colsB;
    
    if (verbose_) {
        std::cout << "Generating instructions for matrix multiplication: " 
                 << matrixC << " = " << matrixA << " * " << matrixB << std::endl;
        std::cout << "  Dimensions: (" << rowsA << "x" << colsA << ") * (" 
                 << rowsB << "x" << colsB << ") = (" << rowsC << "x" << colsC << ")" << std::endl;
    }
    
    // Implementation of matrix multiplication for the pPIM architecture
    // We'll use a simple algorithm that iterates through all elements of C
    // and computes the dot product of the corresponding row in A and column in B
    
    // For matrix multiplication C = A * B:
    // C[i,j] = Σ(k=0 to n-1) A[i,k] * B[k,j]
    
    // Core assignments:
    // Core 0: Multiplier (for partial products)
    // Core 1: Adder (for accumulation)
    // Core 2: MAC (for combining multiply and accumulate)
    
    // Constants for core indices
    constexpr uint8_t MULTIPLIER_CORE = 0;
    constexpr uint8_t ADDER_CORE = 1;
    constexpr uint8_t MAC_CORE = 2;
    
    // We need a nested loop structure to compute each element of C
    for (uint32_t i = 0; i < rowsC; ++i) {
        for (uint32_t j = 0; j < colsC; ++j) {
            // Compute C[i,j] = Σ(k=0 to colsA-1) A[i,k] * B[k,j]
            
            // For each element in C, we need to:
            // 1. Initialize an accumulator to 0
            // 2. For each k, load A[i,k] and B[k,j]
            // 3. Multiply them and add to accumulator
            // 4. Store the final result to C[i,j]
            
            // For the pPIM architecture, we break this down into a sequence of instructions:
            
            // First, load initial values and clear accumulator (read flag only)
            // The accumulator is implicitly cleared when we execute a new MAC operation
            
            // For each k, perform MAC operation
            for (uint32_t k = 0; k < colsA; ++k) {
                // Get memory addresses for A[i,k] and B[k,j]
                uint16_t addrA = memoryMapper_->getElementAddress(matrixA, i, k);
                uint16_t addrB = memoryMapper_->getElementAddress(matrixB, k, j);
                
                // Load A[i,k] (read operation)
                instructions.push_back(PIM_ISA::createMemoryInstruction(0, true, false, addrA));
                
                // Load B[k,j] (read operation)
                instructions.push_back(PIM_ISA::createMemoryInstruction(1, true, false, addrB));
                
                // Execute MACs directly using LUT cores
                // This would ideally be a single MAC operation, but for the pPIM architecture
                // we need to break it down into multiply and accumulate steps
                
                if (k == 0) {
                    // First iteration: multiply only (no accumulation yet)
                    instructions.push_back(PIM_ISA::createComputeInstruction(MULTIPLIER_CORE, 0));
                } else {
                    // Subsequent iterations: multiply and accumulate
                    instructions.push_back(PIM_ISA::createComputeInstruction(MAC_CORE, 0));
                }
            }
            
            // Get memory address for C[i,j]
            uint16_t addrC = memoryMapper_->getElementAddress(matrixC, i, j);
            
            // Store result to C[i,j] (write operation)
            instructions.push_back(PIM_ISA::createMemoryInstruction(2, false, true, addrC));
        }
    }
}

// Generate initialization instructions for LUT cores
void CodeGenerator::generateInitInstructions(std::vector<PIM_ISA::Instruction>& instructions) {
    // Program the multiplier core (Core 0)
    instructions.push_back(PIM_ISA::createProgInstruction(
        0, PIM_ISA::CoreOpType::MULTIPLIER, generateMultiplierConfig()));
    
    // Program the adder core (Core 1)
    instructions.push_back(PIM_ISA::createProgInstruction(
        1, PIM_ISA::CoreOpType::ADDER, generateAdderConfig()));
    
    // Program the MAC core (Core 2)
    instructions.push_back(PIM_ISA::createProgInstruction(
        2, PIM_ISA::CoreOpType::MAC, generateMACConfig()));
}

// Generate LUT configuration for multiplier core
std::vector<uint8_t> CodeGenerator::generateMultiplierConfig() const {
    // This is a simplified implementation for demonstration
    // In a real implementation, this would configure the LUT for 8-bit multiplication
    
    // For now, we'll just return a placeholder configuration
    return {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07};
}

// Generate LUT configuration for adder core
std::vector<uint8_t> CodeGenerator::generateAdderConfig() const {
    // This is a simplified implementation for demonstration
    // In a real implementation, this would configure the LUT for 8-bit addition
    
    // For now, we'll just return a placeholder configuration
    return {0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F};
}

// Generate LUT configuration for MAC core
std::vector<uint8_t> CodeGenerator::generateMACConfig() const {
    // This is a simplified implementation for demonstration
    // In a real implementation, this would configure the LUT for
    // multiply-accumulate operations
    
    // For now, we'll just return a placeholder configuration
    return {0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17};
}

} // namespace Backend

